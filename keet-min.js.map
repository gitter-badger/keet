{"version":3,"sources":["src/components/templateParse/updateState.js","src/components/conditionalNodes.js","src/components/templateParse/conditionalCache.js","src/components/ternaryOps.js","src/components/genModelTemplate.js","src/components/templateParse/diffNodes.js","src/components/genModelList.js","src/components/componentParse.js","src/components/templateParse/replaceCommentBlock.js","src/components/templateParse/valAssign.js","src/components/templateParse/replaceHandleBars.js","src/components/templateParse/inspectAttributes.js","src/components/templateParse/addEvent.js","src/components/templateParse/reconcile.js","src/components/genElement.js","src/components/parseStr.js","src/base/mount.js","utils.js","src/components/strInterpreter.js","keet.js"],"names":["updateState","state","updateStateList","catchNode","node","start","cNode","nextSibling","nodeType","DOCUMENT_ELEMENT_TYPE","isEqualNode","remove","firstChild","resolveConditionalNodes","conditional","setup","runner","addState","currentNode","fetchFrag","frag","document","createDocumentFragment","cache","hasOwnProperty","cloneNode","call","this","parentNode","insertBefore","nodeValue","match","conditionalNodesRawEnd","__pristineFragment__","DOCUMENT_COMMENT_TYPE","appendChild","check","conditionalNodesRawStart","trim","reConditional","concat","nodes","conditionalCache","base","i","length","bind","conditionalNodes","ternaryOps","input","t","split","condition","leftHand","rightHand","value","test","genModelTemplate","string","obj","arrProps","tmpl","len","rep","replace","isTernary","isObjectNotation","strInterpreter","result","undefined","re","isEqual","oldNode","newNode","isIgnored","getAttribute","arbiter","nodeName","checked","setAttr","oAttr","attributes","output","name","iAttr","j","attr","setAttribute","hasAttribute","removeAttribute","patch","diff","replaceChild","getIndex","store","count","ignoreNextSibling","newStore","checkNew","push","index","oldParentNode","checkOld","removeChild","childIsModel","range","createRange","modelRawStart","diffNodes","instance","getId","el","IS_STUB","diffModelNodes","oldModel","newModel","render","str","m","documentFragment","createContextualFragment","removeProtoModel","id","after","p","getElementById","childNodes","Object","keys","map","cache$$1","genModelList","model","reconcile","modelList","listClone","updateOfNew","diffOfOld","pNode","equalLength","child","list","listArg","idx","beforeNode","f","enableFiltering","outerHTML","diffModel","_len","arguments","args","Array","_key","pop","querySelector","lastChild","indexOf","JSON","parse","stringify","checkNodeAvailability","componentParse","componentStr","component","c","cacheInit","ID","callBatchPoolUpdate","assert","replaceCommentBlock","modelRep","valAssign","withTo","RegExp","replaceHandleBars","isAttr","props","ln","tnr","self","ref","inspectAttributes","nodeAttributes","a","ns","localName","lookupParentNode","rootNode","addEvent","evtData","isModel","evtName","handler","addEventListener","fn","e","stopPropagation","target","currentTarget","addEventModel","testEventNode","evtStore","obs","hasChildNodes","modelRaw","recon","_this","hasAttributes","events","clearState","stateList","parseStr","stub","setState","componentDidMount","_mount","tempDiv","createElement","innerHTML","_typeof","DOCUMENT_FRAGMENT_TYPE","DOCUMENT_TEXT_TYPE","genId","rd","Math","random","toString","minId","componentName","callback","notFound","find","ele","clearInterval","found","fail","setInterval","setTimeout","val","msg","Error","notEqual","b","inform","_len2","_key2","exec","apply","createModel","defineProperty","enumerable","configurable","get","set","listFilter","prop","filter","subscribe","add","_extends","kdata-id","update","updateObj","destroy","destroyObj","res","fst","sec","some","inr","predicate","DELAY","morpher","genElement","componentDidUpdate","timer","updateContext","delay","clearTimeout","nextState","isArray","inVal","window","l","console","log","tr","trace","Keet","indentity","mount","link","componentWillMount"],"mappings":"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","file":"keet-min.js","sourcesContent":["export default function (state, updateStateList) {\r\n  if (typeof updateStateList === 'function') updateStateList(state)\r\n}\r\n","const conditionalNodesRawEnd = /\\{\\{\\/([^{}]+)\\}\\}/g\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\n\r\nlet cache = {}\r\n\r\n// rebuild the node structure\r\nfunction catchNode (node, start) {\r\n  let cNode\r\n  while (node) {\r\n    cNode = node\r\n    node = node.nextSibling\r\n    if (cNode && cNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      if (cNode.isEqualNode(start)) {\r\n        cNode.remove()\r\n        start = start.nextSibling\r\n      } else {\r\n        catchNode(cNode.firstChild, start)\r\n      }\r\n    } else if (cNode.isEqualNode(start)) {\r\n      cNode.remove()\r\n      start = start.nextSibling\r\n    }\r\n  }\r\n}\r\n\r\nfunction resolveConditionalNodes (node, conditional, setup, runner, addState) {\r\n  let currentNode\r\n  let cNode\r\n  let fetchFrag\r\n  let frag = document.createDocumentFragment()\r\n  if (setup === 'initial' && !cache.hasOwnProperty(conditional)) {\r\n    cNode = node\r\n    while (cNode) {\r\n      currentNode = cNode\r\n      cNode = cNode.nextSibling\r\n      if (currentNode.nodeType !== DOCUMENT_ELEMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawEnd)) {\r\n        cNode = null\r\n        cache[conditional] = cache[conditional] || {}\r\n        // clean up pristine node\r\n        catchNode(this.__pristineFragment__.firstChild, frag.firstChild)\r\n        // since we work backward no need to check fragment recursive conditional states\r\n        cache[conditional].frag = frag\r\n      } else if (currentNode.nodeType !== DOCUMENT_COMMENT_TYPE) {\r\n        frag.appendChild(currentNode)\r\n      }\r\n    }\r\n  } else if (setup === 'conditional-set') {\r\n    if (node.nextSibling.isEqualNode(cache[conditional].frag.firstChild)) return\r\n    fetchFrag = cache[conditional].frag.cloneNode(true)\r\n    runner.call(this, fetchFrag.firstChild, addState)\r\n    node.parentNode.insertBefore(fetchFrag, node.nextSibling)\r\n  }\r\n}\r\n\r\nexport {\r\n  resolveConditionalNodes as default,\r\n  cache\r\n}\r\n","import updateState from './updateState'\r\nimport conditionalNodes from '../conditionalNodes'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\nconst conditionalNodesRawStart = /\\{\\{\\?([^{}]+)\\}\\}/g\r\nconst reConditional = /([^{?])(.*?)(?=\\}\\})/g\r\n\r\nlet conditional\r\nlet currentNode\r\nlet state\r\nlet nodes\r\n\r\nfunction check (node) {\r\n  while (node) {\r\n    currentNode = node\r\n    node = node.nextSibling\r\n    if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      check.call(this, currentNode.firstChild)\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      conditional = currentNode.nodeValue.trim().match(reConditional)\r\n      state = state.concat(conditional)\r\n      nodes = nodes.concat(currentNode)\r\n    }\r\n  }\r\n}\r\n\r\nfunction conditionalCache (addState) {\r\n  state = []\r\n  nodes = []\r\n  check.call(this, this.base.firstChild)\r\n  let i = state.length\r\n  while (i > 0) {\r\n    i--\r\n    updateState(state[i], addState.bind(this))\r\n    conditionalNodes.call(this, nodes[i], state[i], 'initial')\r\n  }\r\n}\r\n\r\nexport default conditionalCache\r\n","// function to resolve ternary operation\r\n\r\nconst test = str => str === '\\'\\'' || str === '\"\"' || str === 'null' ? '' : str\r\n\r\nexport default function (input) {\r\n  if (input.match(/([^?]*)\\?([^:]*):([^;]*)|(\\s*=\\s*)[^;]*/g)) {\r\n    let t = input.split('?')\r\n    let condition = t[0]\r\n    let leftHand = t[1].split(':')[0]\r\n    let rightHand = t[1].split(':')[1]\r\n\r\n    // check the condition fulfillment\r\n\r\n    if (this) {\r\n      if (this[condition]) {\r\n        return {\r\n          value: test(leftHand),\r\n          state: condition\r\n        }\r\n      } else {\r\n        return {\r\n          value: test(rightHand),\r\n          state: condition\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  } else return false\r\n}\r\n","import ternaryOps from './ternaryOps'\r\nimport strInterpreter from './strInterpreter'\r\n\r\nconst re = new RegExp(/(\\schecked=\")(.*?)(?=\")/g)\r\n\r\nlet tmpl = ''\r\nlet rep\r\nlet isTernary\r\nlet i\r\nlet len\r\nlet match\r\nlet isObjectNotation\r\n\r\nexport default function (string, obj) {\r\n  const arrProps = string.match(/{{([^{}]+)}}/g)\r\n  tmpl = string\r\n  for (i = 0, len = arrProps.length; i < len; i++) {\r\n    rep = arrProps[i].replace(/{{([^{}]+)}}/g, '$1')\r\n    isTernary = ternaryOps.call(obj, rep)\r\n    isObjectNotation = strInterpreter(rep)\r\n    if (isTernary) {\r\n      tmpl = tmpl.replace('{{' + rep + '}}', isTernary.value)\r\n    } else if (isObjectNotation) {\r\n      if (isObjectNotation[0] === 'this' && typeof this[isObjectNotation[1]] === 'function') {\r\n        let result = this[isObjectNotation[1]](obj)\r\n        if (result !== undefined) {\r\n          tmpl = tmpl.replace('{{' + rep + '}}', result)\r\n        }\r\n      }\r\n    } else {\r\n      tmpl = tmpl.replace('{{' + rep + '}}', obj[rep])\r\n    }\r\n\r\n    match = tmpl.match(re)\r\n    if (match) {\r\n      if (match[0].length === 17) { tmpl = tmpl.replace(' checked=\"checked\"', ' checked') } else { tmpl = tmpl.replace(' checked=\"\"', '') }\r\n    }\r\n  }\r\n  return tmpl\r\n}\r\n","import { getId } from '../../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\nconst modelRawStart = /\\{\\{model:([^{}]+)\\}\\}/g\r\n\r\nfunction isEqual (oldNode, newNode) {\r\n  return (\r\n    (isIgnored(oldNode) && isIgnored(newNode)) ||\r\n    oldNode.isEqualNode(newNode)\r\n  )\r\n}\r\n\r\nfunction isIgnored (node) {\r\n  return node.getAttribute('data-ignore') != null\r\n}\r\n\r\nfunction arbiter (oldNode, newNode) {\r\n  if (oldNode.nodeName !== 'INPUT') return\r\n  if (oldNode.checked !== newNode.checked) {\r\n    oldNode.checked = newNode.checked\r\n  }\r\n}\r\n\r\nfunction setAttr (oldNode, newNode) {\r\n  let oAttr = newNode.attributes\r\n  let output = {}\r\n  let i = 0\r\n  while (i < oAttr.length) {\r\n    output[oAttr[i].name] = oAttr[i].value\r\n    i++\r\n  }\r\n  let iAttr = oldNode.attributes\r\n  let input = {}\r\n  let j = 0\r\n  while (j < iAttr.length) {\r\n    input[iAttr[j].name] = iAttr[j].value\r\n    j++\r\n  }\r\n  for (let attr in output) {\r\n    if (oldNode.attributes[attr] && oldNode.attributes[attr].name === attr && oldNode.attributes[attr].value !== output[attr]) {\r\n      oldNode.setAttribute(attr, output[attr])\r\n    } else {\r\n      // add new attributes as long is not part of k-<eventListener>\r\n      if (!oldNode.hasAttribute(attr) && !/^k-/.test(attr)) {\r\n        oldNode.setAttribute(attr, output[attr])\r\n      }\r\n    }\r\n  }\r\n  for (let attr in input) {\r\n    // if attributes does not exist on the new node we removed it from the old node\r\n    if (newNode.attributes[attr] && oldNode.attributes[attr]) {\r\n    } else {\r\n      oldNode.removeAttribute(attr)\r\n    }\r\n  }\r\n}\r\n\r\nfunction patch (oldNode, newNode) {\r\n  if (oldNode.nodeType === newNode.nodeType) {\r\n    if (oldNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      arbiter(oldNode, newNode)\r\n      if (isEqual(oldNode, newNode)) return\r\n      diff(oldNode.firstChild, newNode.firstChild)\r\n      if (oldNode.nodeName === newNode.nodeName) {\r\n        setAttr(oldNode, newNode)\r\n      } else {\r\n        oldNode.parentNode.replaceChild(newNode, oldNode)\r\n      }\r\n    } else {\r\n      if (oldNode.nodeValue !== newNode.nodeValue) {\r\n        oldNode.nodeValue = newNode.nodeValue\r\n      }\r\n    }\r\n  } else {\r\n    oldNode.parentNode.replaceChild(newNode, oldNode)\r\n  }\r\n}\r\n\r\nfunction getIndex (store, count) {\r\n  return store.length - count - 1\r\n}\r\n\r\nlet checkNew\r\nlet checkOld\r\n\r\nfunction diff (oldNode, newNode, ignoreNextSibling) {\r\n  let count = 0\r\n  let newStore = []\r\n  while (newNode) {\r\n    count++\r\n    checkNew = newNode\r\n    newNode = ignoreNextSibling ? null : newNode.nextSibling\r\n    newStore.push(checkNew)\r\n  }\r\n  let index\r\n  let oldParentNode = oldNode && oldNode.parentNode\r\n  while (oldNode) {\r\n    count--\r\n    checkOld = oldNode\r\n    oldNode = ignoreNextSibling ? null : oldNode.nextSibling\r\n    index = getIndex(newStore, count)\r\n    if (checkOld && newStore[index]) {\r\n      patch(checkOld, newStore[index])\r\n    } else if (checkOld && !newStore[index]) {\r\n      oldParentNode.removeChild(checkOld)\r\n    }\r\n    if (oldNode === null) {\r\n      while (count > 0) {\r\n        count--\r\n        index = getIndex(newStore, count)\r\n        oldParentNode.appendChild(newStore[index])\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction childIsModel (node) {\r\n  let range\r\n  if (typeof document.createRange === 'function') {\r\n    range = document.createRange()\r\n  }\r\n  return !range ? range : node.nodeType === DOCUMENT_COMMENT_TYPE && node.nodeValue.match(modelRawStart) !== null\r\n}\r\n\r\nfunction diffNodes (instance) {\r\n  let base = getId(this.el)\r\n  if (base && !this.IS_STUB) {\r\n    diff(base.firstChild, instance)\r\n  } else if (base && !childIsModel(base.firstChild)) {\r\n    diff(base.firstChild, instance.firstChild)\r\n  }\r\n}\r\n\r\nfunction diffModelNodes (oldModel, newModel, ignoreNextSibling) {\r\n  diff(oldModel, newModel, ignoreNextSibling)\r\n}\r\n\r\nexport {\r\n  diffNodes as default,\r\n  diffModelNodes\r\n}\r\n","import { getId, checkNodeAvailability } from '../../utils'\r\nimport genModelTemplate from './genModelTemplate'\r\nimport { cache as conditionalCache } from './conditionalNodes'\r\nimport { diffModelNodes } from './templateParse/diffNodes'\r\n\r\n// diffing two array of objects, including object properties differences\r\nconst diff = (fst, sec) =>\r\n  fst.filter(obj =>\r\n    !sec.some(inr => {\r\n      let predicate = true\r\n      for (let attr in inr) {\r\n        if (obj[attr] !== inr[attr]) {\r\n          predicate = false\r\n        }\r\n      }\r\n      return predicate\r\n    })\r\n  )\r\n\r\n// check if browser support createRange\r\nlet range\r\n\r\nif (typeof document.createRange === 'function') {\r\n  range = document.createRange()\r\n}\r\n\r\n// storage for model state\r\nlet cache = {}\r\nlet m\r\nlet documentFragment\r\n\r\nfunction render (str, obj) {\r\n  m = genModelTemplate.call(this, str, obj)\r\n  documentFragment = range.createContextualFragment(m)\r\n  documentFragment.firstChild.setAttribute('kdata-id', obj['kdata-id'])\r\n}\r\n\r\nfunction removeProtoModel (node, id, after) {\r\n  let p = node.getElementById(id)\r\n  if (p) p.childNodes[1].remove()\r\n  else if (!after) {\r\n    Object.keys(conditionalCache).map(cache =>\r\n      removeProtoModel(conditionalCache[cache].frag, id, true)\r\n    )\r\n  }\r\n}\r\n\r\nfunction genModelList (node, model, reconcile) {\r\n  let modelList\r\n  let i\r\n  let listClone\r\n  let parentNode\r\n  let updateOfNew\r\n  let diffOfOld\r\n  let pNode\r\n  let equalLength\r\n  let child\r\n  let list\r\n  let str\r\n  let oldModel\r\n  let listArg\r\n  let idx\r\n  let beforeNode\r\n  let f\r\n\r\n  cache[model] = cache[model] || {}\r\n\r\n  // check if the model use filtering\r\n  listArg = this[model] && this[model].enableFiltering ? 'listFilter' : 'list'\r\n\r\n  if (!cache[model][listArg]) {\r\n    cache[model][listArg] = node.nextSibling.cloneNode(true)\r\n  }\r\n  list = cache[model][listArg]\r\n\r\n  if (!cache[model].str) {\r\n    cache[model].str = node.nextSibling.cloneNode(true).outerHTML\r\n    // remove the first prototype node\r\n    node.nextSibling.remove()\r\n    // also remove from pristine nodes / conditional cache store\r\n    removeProtoModel(this.__pristineFragment__, node.parentNode.id)\r\n  }\r\n  str = cache[model].str\r\n\r\n  if (this[model] !== undefined && this[model].hasOwnProperty(listArg)) {\r\n    parentNode = node.parentNode\r\n\r\n    if (range && !parentNode.hasAttribute('data-ignore')) {\r\n      parentNode.setAttribute('data-ignore', '')\r\n    }\r\n\r\n    modelList = this[model][listArg]\r\n\r\n    oldModel = cache[model].oldModel || []\r\n\r\n    // check if current browser doesn't support createRange()\r\n    if (!range) {\r\n      i = 0\r\n      while (i < modelList.length) {\r\n        // fallback to regular node generation handler\r\n        listClone = list.cloneNode(true)\r\n        reconcile.call(this, listClone, null, modelList[i])\r\n        listClone.setAttribute('kdata-id', modelList[i]['kdata-id'])\r\n        parentNode.insertBefore(listClone, parentNode.lastChild)\r\n        i++\r\n      }\r\n    } else {\r\n      updateOfNew = diff(modelList, oldModel)\r\n      diffOfOld = diff(oldModel, modelList)\r\n\r\n      const diffModel = function (...args) {\r\n        pNode = args.pop()\r\n        // check if both models are equally in length\r\n        equalLength = oldModel.length === modelList.length\r\n\r\n        if (equalLength && pNode.childNodes.length !== 2) {\r\n          i = 0\r\n          while (i < updateOfNew.length) {\r\n            if (updateOfNew[i]['kdata-id'] === diffOfOld[i]['kdata-id']) {\r\n              // equal node element id\r\n              child = pNode.querySelector(`[kdata-id=\"${updateOfNew[i]['kdata-id']}\"]`)\r\n            } else {\r\n              // replace if it doesn't share the same id\r\n              child = pNode.querySelector(`[kdata-id=\"${diffOfOld[i]['kdata-id']}\"]`)\r\n            }\r\n            if (child) {\r\n              render.call(this, str, updateOfNew[i])\r\n              // pNode.replaceChild(documentFragment, child)\r\n              diffModelNodes(child, documentFragment.firstChild, true)\r\n            }\r\n            i++\r\n          }\r\n        // add new objects\r\n        } else if (updateOfNew.length > 0 && diffOfOld.length === 0) {\r\n          i = 0\r\n          while (i < updateOfNew.length) {\r\n            render.call(this, str, updateOfNew[i])\r\n            if (updateOfNew[i]['kdata-id'] === modelList[modelList.length - 1]['kdata-id']) {\r\n              beforeNode = pNode.lastChild\r\n            } else {\r\n              idx = modelList.map(m => m['kdata-id']).indexOf(updateOfNew[i]['kdata-id'])\r\n              beforeNode = pNode.childNodes[idx].nextSibling\r\n            }\r\n            pNode.insertBefore(documentFragment, beforeNode)\r\n            i++\r\n          }\r\n        // destroy selected objects\r\n        } else if (updateOfNew.length === 0 && diffOfOld.length > 0) {\r\n          i = 0\r\n          while (i < diffOfOld.length) {\r\n            child = pNode.querySelector(`[kdata-id=\"${diffOfOld[i]['kdata-id']}\"]`)\r\n            if (child) {\r\n              pNode.removeChild(child)\r\n            }\r\n            i++\r\n          }\r\n        } else if (updateOfNew.length > 0 && diffOfOld.length > 0) {\r\n          // if both differences has length we remove the old children and replace it with the new ones\r\n          i = 0\r\n          while (i < diffOfOld.length) {\r\n            child = pNode.querySelector(`[kdata-id=\"${diffOfOld[i]['kdata-id']}\"]`)\r\n            if (child) {\r\n              pNode.removeChild(child)\r\n            }\r\n            i++\r\n            if (i === diffOfOld.length) {\r\n              f = 0\r\n              while (f < updateOfNew.length) {\r\n                render.call(this, str, updateOfNew[f])\r\n                pNode.insertBefore(documentFragment, pNode.lastChild)\r\n                f++\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          i = 0\r\n          while (i < modelList.length) {\r\n            render.call(this, str, modelList[i])\r\n            pNode.insertBefore(documentFragment, pNode.lastChild)\r\n            i++\r\n          }\r\n        }\r\n        // replace oldModel after diffing\r\n        cache[model].oldModel = JSON.parse(JSON.stringify(modelList))\r\n      }\r\n\r\n      // check existing parentNode in the DOM\r\n      if (parentNode.hasAttribute('id')) {\r\n        pNode = getId(parentNode.id)\r\n        if (pNode) {\r\n          diffModel.call(this, null, null, pNode)\r\n        } else {\r\n          checkNodeAvailability({ el: parentNode.id }, model, diffModel.bind(this), function () {\r\n            // we cleanup cache on failed search\r\n            cache[model].oldModel = []\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default genModelList\r\n","import { assert, getId } from '../../utils'\r\n\r\nlet cacheInit = {}\r\n\r\nexport default function (componentStr, node) {\r\n  const component = componentStr.replace('component:', '')\r\n  const c = this[component]\r\n  if (c !== undefined) {\r\n    // this is for initial component runner\r\n    if (!cacheInit[c.ID]) {\r\n      c.render(true)\r\n      cacheInit[c.ID] = c.base.cloneNode(true)\r\n      node.parentNode.replaceChild(c.base, node)\r\n    } else {\r\n      // we need to reattach event listeners if the node is not available on DOM\r\n      if (!getId(this[component].el)) {\r\n        c.base = c.__pristineFragment__.cloneNode(true)\r\n        c.render(true)\r\n        node.parentNode.replaceChild(c.base, node)\r\n      } else {\r\n        node.parentNode.replaceChild(cacheInit[c.ID].cloneNode(true), node)\r\n        // inform sub-component to update\r\n        c.callBatchPoolUpdate()\r\n      }\r\n    }\r\n  } else {\r\n    assert(false, 'Component ' + component + ' does not exist.')\r\n  }\r\n}\r\n","import genModelList from '../genModelList'\r\nimport componentParse from '../componentParse'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\nconst model = /^model:/g\r\nconst component = /^component:([^{}]+)/g\r\n\r\nexport default function (value, node, reconcile) {\r\n  let rep\r\n  let modelRep\r\n\r\n  if (value.match(re)) {\r\n    rep = value.replace(re, '$1').trim()\r\n    if (rep.match(model)) {\r\n      modelRep = rep.replace('model:', '')\r\n      genModelList.call(this, node, modelRep, reconcile)\r\n    } else if (rep.match(component)) {\r\n      componentParse.call(this, rep, node)\r\n    }\r\n  }\r\n}\r\n","export default function (node, value, replace, withTo) {\r\n  let re = new RegExp(replace, 'g')\r\n  node.nodeValue = node.nodeValue.replace(re, withTo)\r\n}\r\n","import ternaryOps from '../ternaryOps'\r\nimport strInterpreter from '../strInterpreter'\r\nimport updateState from './updateState'\r\nimport valAssign from './valAssign'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nexport default function (value, node, addState, isAttr, model) {\r\n  const props = value.match(re)\r\n  if (!props) return\r\n  let ln = props.length\r\n  let rep\r\n  let tnr\r\n  let isObjectNotation\r\n\r\n  let self = this\r\n\r\n  let ref = model || this\r\n\r\n  while (ln) {\r\n    ln--\r\n    rep = props[ln].replace(re, '$1')\r\n    tnr = ternaryOps.call(ref, rep)\r\n    isObjectNotation = strInterpreter(rep)\r\n    if (isObjectNotation) {\r\n      if (!isAttr) {\r\n        if (isObjectNotation[0] === 'this' && self[isObjectNotation[1]] !== undefined && typeof self[isObjectNotation[1]] === 'function') {\r\n          let result = self[isObjectNotation[1]]()\r\n          if (result !== undefined) {\r\n            valAssign(node, value, '{{' + rep + '}}', result)\r\n          }\r\n        } else {\r\n          updateState(rep, addState)\r\n          valAssign(node, value, '{{' + rep + '}}', self[isObjectNotation[0]][isObjectNotation[1]])\r\n        }\r\n      } else {\r\n        if (isObjectNotation[0] === 'this' && self[isObjectNotation[1]] !== undefined && typeof self[isObjectNotation[1]] === 'function') {\r\n          let result = self[isObjectNotation[1]](ref)\r\n          return result !== undefined ? result : value\r\n        } else {\r\n          updateState(rep, addState)\r\n          return value.replace(props, self[isObjectNotation[0]][isObjectNotation[1]])\r\n        }\r\n      }\r\n    } else {\r\n      if (tnr) {\r\n        updateState(tnr.state, addState)\r\n        if (!isAttr) {\r\n          valAssign(node, value, '{{' + rep + '}}', tnr.value)\r\n        } else {\r\n          return value.replace(props, tnr.value)\r\n        }\r\n      } else {\r\n        if (ref[rep] !== undefined) {\r\n          updateState(rep, addState)\r\n          if (!isAttr) {\r\n            valAssign(node, value, '{{' + rep + '}}', ref[rep])\r\n          } else {\r\n            return value.replace(props, ref[rep])\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import replaceHandleBars from './replaceHandleBars'\r\n\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nfunction inspectAttributes (node, addState, model) {\r\n  let nodeAttributes = node.attributes\r\n  let i = 0\r\n  let a\r\n  let ns\r\n  let name\r\n\r\n  for (i = nodeAttributes.length; i--;) {\r\n    a = nodeAttributes[i]\r\n    name = a.localName\r\n    ns = a.nodeValue\r\n    if (re.test(name)) {\r\n      node.removeAttribute(name)\r\n      name = replaceHandleBars.call(this, name, node, addState, true, model)\r\n      node.setAttribute(name, ns)\r\n    } else if (re.test(ns)) {\r\n      ns = replaceHandleBars.call(this, ns, node, addState, true, model)\r\n      if (name === 'checked') {\r\n        if (ns === '') {\r\n          node.checked = false\r\n        } else {\r\n          node.checked = true\r\n        }\r\n        node.removeAttribute(name)\r\n      } else {\r\n        if (ns === '') {\r\n          node.setAttribute(name, '')\r\n        } else {\r\n          node.setAttribute(name, ns)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default inspectAttributes\r\n","const DOCUMENT_ELEMENT_TYPE = 1\r\nconst re = /{{([^{}]+)}}/g\r\n\r\nfunction lookupParentNode (rootNode, node) {\r\n  let cNode\r\n  while (node) {\r\n    cNode = node\r\n    node = node.parentNode\r\n    if (cNode.nodeType === DOCUMENT_ELEMENT_TYPE && cNode.hasAttribute('kdata-id')) {\r\n      return { id: cNode.getAttribute('kdata-id'), node: cNode }\r\n    }\r\n    if (cNode.isEqualNode(rootNode)) {\r\n      node = null\r\n    }\r\n  }\r\n}\r\n\r\nconst getIndex = (id, model) => model.list.map(m => m['kdata-id']).indexOf(id)\r\n\r\nfunction addEvent (node, evtData) {\r\n  delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    node.addEventListener(evtName, this[handler].bind(this), !!evtData['useCapture'])\r\n  }\r\n}\r\n\r\nfunction fn (model, handler, node, e) {\r\n  e.stopPropagation()\r\n  if (e.target !== e.currentTarget) {\r\n    let t = lookupParentNode(node, e.target)\r\n    this[handler](model.list[getIndex(t.id, model)], e.target, t.node, e)\r\n  }\r\n}\r\n\r\nfunction addEventModel (node, evtData) {\r\n  delete evtData.isModel\r\n  let evtName = Object.keys(evtData)[0]\r\n  let handler = evtData[evtName]\r\n  if (this[handler] !== undefined && typeof this[handler] === 'function') {\r\n    let rep = node.firstChild.nodeValue.replace(re, '$1').trim()\r\n    rep = rep.replace('model:', '')\r\n    let model = this[rep]\r\n    node.addEventListener(evtName, fn.bind(this, model, handler, node), !!evtData['useCapture'])\r\n  }\r\n}\r\n\r\nexport {\r\n  addEvent,\r\n  addEventModel\r\n}\r\n","import replaceCommentBlock from './replaceCommentBlock'\r\nimport inspectAttributes from './inspectAttributes'\r\nimport replaceHandleBars from './replaceHandleBars'\r\nimport conditionalNodes from '../conditionalNodes'\r\n\r\nimport { getId } from '../../../utils'\r\nimport { addEvent, addEventModel } from './addEvent'\r\n\r\nconst conditionalNodesRawStart = /\\{\\{\\?([^{}]+)\\}\\}/g\r\nconst reConditional = /([^{?])(.*?)(?=\\}\\})/g\r\nconst re = /{{([^{}]+)}}/g\r\nconst modelRaw = /\\{\\{model:([^{}]+)\\}\\}/g\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\nconst DOCUMENT_COMMENT_TYPE = 8\r\n\r\nfunction testEventNode (node) {\r\n  let nodeAttributes = node.attributes\r\n  let i = 0\r\n  let a\r\n  let name\r\n  let value\r\n  let evtName\r\n  let handler\r\n  let evtStore = []\r\n  let obs\r\n  let args\r\n\r\n  while (i < nodeAttributes.length) {\r\n    a = nodeAttributes[i]\r\n    name = a.localName\r\n    value = a.nodeValue\r\n    if (/^k-/.test(name)) {\r\n      evtName = name.replace(/^k-/, '')\r\n      handler = value.match(/[a-zA-Z]+(?![^(]*\\))/)[0]\r\n      args = value.match(/\\(([^{}]+)\\)/)\r\n      args = args ? args[1] : ''\r\n      obs = {}\r\n      obs[evtName] = handler\r\n      if (args) obs[args] = true\r\n      obs['isModel'] = false\r\n      evtStore.push(obs)\r\n      if (node.hasChildNodes() && node.firstChild.nodeType !== DOCUMENT_ELEMENT_TYPE && node.firstChild.nodeValue.match(modelRaw)) {\r\n        obs['isModel'] = true\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  return evtStore\r\n}\r\n\r\nlet events\r\nlet c\r\nlet currentNode\r\n\r\nfunction recon (node, addState, model) {\r\n  while (node) {\r\n    currentNode = node\r\n    node = node.nextSibling\r\n    if (currentNode.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      if (currentNode.hasAttributes()) {\r\n        inspectAttributes.call(this, currentNode, addState, model)\r\n\r\n        // to take advantage of caching always assigned id to the node\r\n        // we only assign eventListener on first mount to DOM or when the node is not available on DOM\r\n        if (!getId(currentNode.id)) {\r\n          events = testEventNode.call(this, currentNode)\r\n          if (events.length) {\r\n            events.map(e => {\r\n              !e.isModel ? addEvent.call(this, currentNode, e) : addEventModel.call(this, currentNode, e)\r\n              currentNode.removeAttribute(`k-${Object.keys(e)[0]}`)\r\n            })\r\n          }\r\n        }\r\n      }\r\n      recon.call(this, currentNode.firstChild, addState, model)\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      c = currentNode.nodeValue.trim().match(reConditional)\r\n      c = c && c[0]\r\n      if (this[c]) {\r\n        conditionalNodes.call(this, currentNode, c, 'conditional-set', reconcile, addState)\r\n      }\r\n    } else if (currentNode.nodeType === DOCUMENT_COMMENT_TYPE && currentNode.nodeValue.match(re) && !currentNode.nodeValue.match(conditionalNodesRawStart)) {\r\n      replaceCommentBlock.call(this, currentNode.nodeValue, currentNode, reconcile)\r\n    } else {\r\n      replaceHandleBars.call(this, currentNode.nodeValue, currentNode, addState, null, model)\r\n    }\r\n  }\r\n}\r\n\r\nfunction reconcile (instance, addState, model) {\r\n  recon.call(this, instance, addState, model)\r\n}\r\n\r\nexport default reconcile\r\n","// import conditionalSet from './templateParse/conditionalSet'\r\nimport reconcile from './templateParse/reconcile'\r\n// import eventBuff from './templateParse/eventBuff'\r\nimport diffNodes from './templateParse/diffNodes'\r\nimport strInterpreter from './strInterpreter'\r\n\r\nconst DELAY = 0\r\n\r\nconst morpher = function () {\r\n  genElement.call(this)\r\n  // exec life-cycle componentDidUpdate\r\n  if (this.componentDidUpdate && typeof this.componentDidUpdate === 'function') {\r\n    this.componentDidUpdate()\r\n  }\r\n}\r\n\r\nlet timer = {}\r\n\r\nconst updateContext = function (fn, delay) {\r\n  timer[this.ID] = timer[this.ID] || null\r\n  clearTimeout(timer[this.ID])\r\n  timer[this.ID] = setTimeout(() => fn.call(this), delay)\r\n}\r\n\r\nconst nextState = function (i) {\r\n  let self = this\r\n  let state\r\n  let value\r\n  if (!stateList[this.ID]) return\r\n  if (i < stateList[this.ID].length) {\r\n    state = stateList[this.ID][i]\r\n    value = this[state]\r\n\r\n    // if value is undefined, likely has object notation we convert it to array\r\n    if (value === undefined) value = strInterpreter(state)\r\n\r\n    if (value && Array.isArray(value)) {\r\n      // using split object notation as base for state update\r\n      let inVal = this[value[0]][value[1]]\r\n\r\n      Object.defineProperty(this[value[0]], value[1], {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return inVal\r\n        },\r\n        set: function (val) {\r\n          inVal = val\r\n          updateContext.call(self, morpher, DELAY)\r\n        }\r\n      })\r\n    } else {\r\n      // handle parent state update if the state is not an object\r\n      Object.defineProperty(this, state, {\r\n        enumerable: false,\r\n        configurable: true,\r\n        get: function () {\r\n          return value\r\n        },\r\n        set: function (val) {\r\n          value = val\r\n          updateContext.call(self, morpher, DELAY)\r\n        }\r\n      })\r\n    }\r\n    i++\r\n    nextState.call(this, i)\r\n  }\r\n}\r\n\r\nconst setState = function () {\r\n  nextState.call(this, 0)\r\n}\r\n\r\nlet stateList = {}\r\n\r\nfunction clearState () {\r\n  if (stateList[this.ID]) stateList[this.ID] = []\r\n}\r\n\r\nfunction addState (state) {\r\n  stateList[this.ID] = stateList[this.ID] || []\r\n  if (stateList[this.ID].indexOf(state) === -1) { stateList[this.ID] = stateList[this.ID].concat(state) }\r\n}\r\n\r\nconst genElement = function () {\r\n  this.base = this.__pristineFragment__.cloneNode(true)\r\n  // conditionalSet.call(this, this.base.firstChild)\r\n  reconcile.call(this, this.base.firstChild, addState.bind(this))\r\n  // eventBuff.call(this, this.base.firstChild)\r\n  diffNodes.call(this, this.base.firstChild)\r\n}\r\n\r\nexport {\r\n  genElement,\r\n  addState,\r\n  setState,\r\n  clearState,\r\n  updateContext,\r\n  morpher\r\n}\r\n","import conditionalCache from './templateParse/conditionalCache'\r\n// import conditionalSet from './templateParse/conditionalSet'\r\nimport reconcile from './templateParse/reconcile'\r\n// import eventBuff from './templateParse/eventBuff'\r\nimport { setState, addState } from './genElement'\r\nimport { getId, assert } from '../../utils'\r\n\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n\r\nexport default function (stub) {\r\n  conditionalCache.call(this, addState.bind(this))\r\n  // conditionalSet.call(this, this.base.firstChild)\r\n  reconcile.call(this, this.base.firstChild, addState.bind(this))\r\n  // eventBuff.call(this, this.base.firstChild)\r\n  const el = stub || getId(this.el)\r\n  if (el) {\r\n    if (el.nodeType === DOCUMENT_ELEMENT_TYPE) {\r\n      el.setAttribute('data-ignore', '')\r\n    } else {\r\n      assert(this.base.childNodes.length === 1, 'Sub-component should only has a single rootNode.')\r\n      !this.base.firstChild.hasAttribute('data-ignore') && this.base.firstChild.setAttribute('data-ignore', '')\r\n    }\r\n    // listen to state changes\r\n    setState.call(this)\r\n    // mount fragment to DOM\r\n    if (!stub) {\r\n      el.appendChild(this.base)\r\n    }\r\n\r\n    // since component already rendered, trigger its life-cycle method\r\n    if (this.componentDidMount && typeof this.componentDidMount === 'function') {\r\n      this.componentDidMount()\r\n    }\r\n  } else {\r\n    assert(false, 'No element with id: \"' + this.el + '\" exist.')\r\n  }\r\n}\r\n","import { clearState } from '../components/genElement'\r\nimport { assert } from '../../utils'\r\n\r\nconst DOCUMENT_FRAGMENT_TYPE = 11\r\nconst DOCUMENT_TEXT_TYPE = 3\r\nconst DOCUMENT_ELEMENT_TYPE = 1\r\n/**\r\n * @private\r\n * @description\r\n * Mount an instance of string or html elements\r\n *\r\n * @param {String|Object} instance - the html/string\r\n */\r\nexport default function (instance) {\r\n  let base\r\n  let tempDiv\r\n  let frag = document.createDocumentFragment()\r\n  // Before we begin to parse an instance, do a run-down checks\r\n  // to clean up back-tick string which usually has line spacing.\r\n  if (typeof instance === 'string') {\r\n    base = instance.trim().replace(/\\s+/g, ' ')\r\n    tempDiv = document.createElement('div')\r\n    tempDiv.innerHTML = base\r\n    while (tempDiv.firstChild) {\r\n      frag.appendChild(tempDiv.firstChild)\r\n    }\r\n  // If instance is a html element process as html entities\r\n  } else if (typeof instance === 'object' && instance['nodeType']) {\r\n    if (instance['nodeType'] === DOCUMENT_ELEMENT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else if (instance['nodeType'] === DOCUMENT_FRAGMENT_TYPE) {\r\n      frag = instance\r\n    } else if (instance['nodeType'] === DOCUMENT_TEXT_TYPE) {\r\n      frag.appendChild(instance)\r\n    } else {\r\n      assert(false, 'Unable to parse instance, unknown type.')\r\n    }\r\n  } else {\r\n    assert(false, 'Parameter is not a string or a html element.')\r\n  }\r\n  // we store the pristine instance in __pristineFragment__\r\n  this.__pristineFragment__ = frag.cloneNode(true)\r\n  this.base = frag\r\n\r\n  // cleanup states on mount\r\n  clearState.call(this)\r\n  return this\r\n}\r\n","const genId = () => {\r\n  const rd = () => (Math.random() * 1 * 1e17).toString(36)\r\n  return `KDATA-${rd()}-${rd()}`\r\n}\r\n\r\nconst minId = () => (Math.random() * 1 * 1e17).toString(36)\r\n\r\nconst getId = id => document.getElementById(id)\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Check a node availability in 100ms, if not found silenty skip the event\r\n * or execute a callback\r\n *\r\n * @param {string} id - the node id\r\n * @param {function} callback - the function to execute on success\r\n * @param {function} notFound - the function to execute on failed\r\n */\r\nconst checkNodeAvailability = (component, componentName, callback, notFound) => {\r\n  let ele = getId(component.el)\r\n  let found = false\r\n  let t\r\n  function find () {\r\n    ele = getId(component.el)\r\n    if (ele) {\r\n      clearInterval(t)\r\n      found = true\r\n      callback(component, componentName, ele)\r\n    }\r\n  }\r\n  function fail () {\r\n    clearInterval(t)\r\n    if (!found && notFound && typeof notFound === 'function') notFound()\r\n  }\r\n  if (ele) return ele\r\n  else {\r\n    t = setInterval(find, 0)\r\n    // ignore finding the node after sometimes\r\n    setTimeout(fail, 5)\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Confirm that a value is truthy, throws an error message otherwise.\r\n *\r\n * @param {*} val - the val to test.\r\n * @param {string} msg - the error message on failure.\r\n * @throws {Error}\r\n */\r\nconst assert = (val, msg) => {\r\n  if (!val) throw new Error('(keet) ' + msg)\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Simple html template literals MODIFIED from : http://2ality.com/2015/01/template-strings-html.html\r\n * by Dr. Axel Rauschmayer\r\n * no checking for wrapping in root element\r\n * no strict checking\r\n * remove spacing / indentation\r\n * keep all spacing within html tags\r\n * include handling ${} in the literals\r\n */\r\nconst html = (...args) => {\r\n  const literals = args.shift()\r\n  const substs = args.slice()\r\n\r\n  let result = literals.raw.reduce((acc, lit, i) => acc + substs[i - 1] + lit)\r\n  // remove spacing, indentation from every line\r\n  result = result.split(/\\n+/)\r\n  result = result.map(t => t.trim()).join('')\r\n  return result\r\n}\r\n\r\nconst notEqual = function (a, b) {\r\n  return a['kdata-id'] !== b['kdata-id']\r\n}\r\n\r\nconst inform = function (...args) {\r\n  this.exec && typeof this.exec === 'function' && this.exec.apply(null, args)\r\n}\r\n\r\n/**\r\n * @private\r\n * @description\r\n * Copy with modification from preact-todomvc. Model constructor with\r\n * registering callback listener in Object.defineProperty. Any modification\r\n * to ```this.list``` instance will subsequently inform all registered listener.\r\n *\r\n * {{model:<myModel>}}<myModelTemplateString>{{/model:<myModel>}}\r\n *\r\n */\r\nclass createModel {\r\n  constructor (enableFiltering) {\r\n    // if enableFiltering is assigned a value, model generation will\r\n    // use `listFilter` instead of `list`\r\n    this.enableFiltering = enableFiltering || null\r\n\r\n    this.exec = null\r\n\r\n    this.model = []\r\n\r\n    // Register callback listener of any changes\r\n    Object.defineProperty(this, 'list', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function () {\r\n        return this.model\r\n      },\r\n      set: function (val) {\r\n        this.model = val\r\n        inform.call(this, this.model, this.listFilter)\r\n      }\r\n    })\r\n\r\n    // Register callback listener of any changes with filter\r\n    Object.defineProperty(this, 'listFilter', {\r\n      enumerable: false,\r\n      configurable: true,\r\n      get: function () {\r\n        return !this.prop ? this.model : this.model.filter(obj => obj[this.prop] === this.value)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @description\r\n   * Subscribe to the model changes (add/update/destroy)\r\n   *\r\n   * @param {Object} model - the model including all prototypes\r\n   *\r\n   */\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @description\r\n   * Add new object to the model list\r\n   *\r\n   * @param {Object} obj - new object to add into the model list\r\n   *\r\n   */\r\n  add (obj) {\r\n    this.list = this.list.concat({ ...obj, 'kdata-id': minId() })\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @description\r\n   * Update existing object in the model list\r\n   *\r\n   * @param {String} lookupId - lookup id property name of the object\r\n   * @param {Object} updateObj - the updated properties\r\n   *\r\n   */\r\n  update (updateObj) {\r\n    this.list = this.list.map(obj =>\r\n      notEqual(obj, updateObj) ? obj : updateObj\r\n    )\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @description\r\n   * Filter the model data by selected properties, constructor\r\n   * instantiation should be apply with boolean true as argument\r\n   * to enable filtering\r\n   * @param {String} prop - property of the object\r\n   * @param {String|Boolean|Interger} value - property value\r\n   *\r\n   */\r\n  filter (prop, value) {\r\n    this.prop = prop\r\n    this.value = value\r\n    this.list = this.list.map(obj => obj)\r\n  }\r\n\r\n  /**\r\n * @private\r\n * @description\r\n * Removed existing object in the model list\r\n *\r\n * @param {String} lookupId - lookup id property name of the object\r\n * @param {String} objId - unique identifier of the lookup id\r\n *\r\n */\r\n  destroy (destroyObj) {\r\n    this.list = this.list.filter(obj =>\r\n      notEqual(obj, destroyObj)\r\n    )\r\n  }\r\n}\r\n\r\nexport {\r\n  createModel,\r\n  html,\r\n  assert,\r\n  checkNodeAvailability,\r\n  genId,\r\n  getId,\r\n  minId\r\n}\r\n","export default (str) => {\r\n  let res = str.match(/\\.*\\./g)\r\n  let result\r\n  if (res && res.length > 0) {\r\n    return str.split('.')\r\n  }\r\n  return result\r\n}\r\n","\r\n/**\r\n * Keetjs v4.0.0 Alpha release: https://github.com/keetjs/keet\r\n * Minimalist view layer for the web\r\n *\r\n * <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Keetjs >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n *\r\n * Copyright 2018, Shahrul Nizam Selamat\r\n * Released under the MIT License.\r\n */\r\n\r\nimport parseStr from './src/components/parseStr'\r\nimport { updateContext, morpher } from './src/components/genElement'\r\nimport { genId, assert, html, createModel } from './utils'\r\nimport mount from './src/base/mount'\r\n\r\nwindow.l = console.log.bind(console)\r\nwindow.tr = console.trace.bind(console)\r\n\r\n/**\r\n * @description\r\n * The main constructor of Keet\r\n */\r\nclass Keet {\r\n  constructor () {\r\n    this.ID = Keet.indentity\r\n  }\r\n\r\n  // generate ID for the component\r\n  static get indentity () {\r\n    return genId()\r\n  }\r\n\r\n  mount (instance) {\r\n    return mount.call(this, instance)\r\n  }\r\n\r\n  link (id) {\r\n    // The target DOM where the rendering will took place.\r\n    if (!id) assert(id, 'No id is given as parameter.')\r\n    this.el = id\r\n    this.render()\r\n    return this\r\n  }\r\n\r\n  render (stub) {\r\n    // life-cycle method before rendering the component\r\n    if (this.componentWillMount && typeof this.componentWillMount === 'function') {\r\n      this.componentWillMount()\r\n    }\r\n\r\n    // Render this component to the target DOM\r\n    if (stub) {\r\n      this.IS_STUB = true\r\n    }\r\n    parseStr.call(this, stub)\r\n  }\r\n\r\n  callBatchPoolUpdate () {\r\n    // force component to update, if any state / non-state\r\n    // value changed DOM diffing will occur\r\n    updateContext.call(this, morpher, 1)\r\n  }\r\n\r\n  subscribe (fn) {\r\n    this.exec = fn\r\n  }\r\n\r\n  inform (model) {\r\n    this.exec && typeof this.exec === 'function' && this.exec(model)\r\n  }\r\n}\r\n\r\nexport {\r\n  Keet as default,\r\n  html,\r\n  createModel\r\n}\r\n"]}